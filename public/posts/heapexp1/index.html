<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Heap Exploitation Part 1 | Mr_N₁gativ3</title>
<meta name="keywords" content="">
<meta name="description" content="Exploring GLIBC Heap">
<meta name="author" content="Mr_N1">
<link rel="canonical" href="http://localhost:1313/posts/heapexp1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2846fd1f2998a1fa9b915df960aef781eb2a0bd48e18d1d90d158327a491a7a3.css" integrity="sha256-KEb9HymYofqbkV35YK73gesqC9SOGNHZDRWDJ6SRp6M=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/heapexp1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/posts/heapexp1/">
  <meta property="og:site_name" content="Mr_N₁gativ3">
  <meta property="og:title" content="Heap Exploitation Part 1">
  <meta property="og:description" content="Exploring GLIBC Heap">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-06-10T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Heap Exploitation Part 1">
<meta name="twitter:description" content="Exploring GLIBC Heap">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Heap Exploitation Part 1",
      "item": "http://localhost:1313/posts/heapexp1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Heap Exploitation Part 1",
  "name": "Heap Exploitation Part 1",
  "description": "Exploring GLIBC Heap",
  "keywords": [
    
  ],
  "articleBody": "Intro This is the first part of the heap exploitation series in this post i will give you an basic overview of glibc heap implementation and discuss about some basic terminologies and in the upcoming post we will take a look at how the memory allocation takes place and how it gets free and further we will look at different heap related vulnerabilities and see how to exploit them.\nWhat is Heap and Why? Heap is a type of memory used in programs to store data that needs to be dynamically allocated and can change in size during the program’s execution. The programmer can request chunk of memory from the heap and the heap manager will allocate that chunk to the program. To request a chunk of memory on heap we use malloc function and provide the size of memory that we need and it will return a pointer to that allocated chunk and using free function we can deallocate that chunk form the heap. It is very effective method for allocating memory which lives in a program for long period time and the size of the memory can be expended when its fully exhausted. You can do that using sbrk or mmap system call and when the memory is no longer needed you can free it.\nYou may be wondering why don’t we use stack it also get’s the job done.\nThink about a scenario where you have a dynamic game in which there are multiple items and your player collect those items and the size of its inventory grow. Using the heap, you can easily expand the inventory array as needed without worrying about the fixed size limitations of the stack.\nOR\nWhen the player enters a new area in the game, you might need to create 100 new enemy objects. Allocating these on the stack could quickly exhaust stack space, leading to stack overflow. The heap, on the other hand, can handle such allocations more gracefully. In some case some enemies often need to alive for entire game or for some specific amount of time. The stack is unsuitable for such long-lived objects as it is designed for temporary storage within function calls. which means when the function exits the memory allocated for those variable will be reclaimed by the stack.\nMemory layout example of x86-64 architecture\nOn a 64-bit Linux system, the stack might start at around 0x7fffffffffff and grow downwards Heap might start at around 0x600000000000 on a 64-bit system and grow upwards BSS segment addresses might be in the lower range, just above the data segment. Data segment Typically located just above the code segment Code segment might start at a fixed low address, such as 0x00400000 on a 64-bit Linux system High Memory Addresses +------------------+ | Stack | 0x7fffffffffff {Top of stack} | | | | v | | | | (grows downward) | +------------------+ | | | ^ | | | | | Heap | | (grows upward) | 0x600000000000 {Start of heap} +------------------+ | BSS Segment | +------------------+ | Data Segment | +------------------+ | Code Segment | 0x00400000 {Start of code segment} +------------------+ Low Memory Addresses History of Dynamic Memory Allocator Memory allocators are fundamental components of modern computer systems, responsible for managing dynamic memory allocation and deallocation. Over the years, several allocators have been developed, each optimized for different use cases and performance scenarios.\nOne of the earliest and most influential memory allocators was dlmalloc, developed by Doug Lea in 1987. Initially designed as a general-purpose allocator, dlmalloc became widely used due to its efficiency and portability across different systems.\nIn the early days of Linux and Unix-like systems, dlmalloc (Doug Lea’s malloc) was indeed one of the most commonly used memory allocators due to its efficiency and portability. However, the transition to ptmalloc (POSIX threads malloc) was driven by the need to support multi-threaded applications more effectively.\nThe current memory allocater used in linux is ptmalloc3 it is an evolution of the ptmalloc (POSIX threads malloc) allocator, which itself is a fork of Doug Lea’s original dlmalloc. ptmalloc3 represents a significant enhancement over its predecessors, focusing on improving performance and scalability for multi-threaded applications.\nThere are several other memory allocators created and used by different platforms\njemalloc initially created for FreeBSD, offers scalable multi-threaded memory allocation\ntcmalloc (Thread-Caching malloc), developed by Google, is optimized for performance in multi-threaded environments\nmimalloc introduced by Microsoft, focuses on compact memory usage, low latency, and high concurrency.\nArenas Arenas in ptmalloc are dedicated memory management regions assigned to individual threads within the GLIBC heap allocator. Each thread that interacts with the heap is associated with its own arena. This design allows threads to perform memory allocations and deallocations independently, minimizing contention and improving performance in multi-threaded applications. Arenas manage memory blocks and metadata specific to each thread, optimizing memory usage and reducing synchronization overhead. When a thread requests memory from the heap, it interacts solely with its designated arena, ensuring efficient and scalable memory management across concurrent threads. Multiple arenas can exist simultaneously, dynamically created and managed by ptmalloc based on the application’s threading requirements.\nThread A +----------------------------------+ | Arena A (Thread-specific) | | +-----------------------------+ | | | Memory Blocks | | | +-----------------------------+ | +----------------------------------+ Thread B +----------------------------------+ | Arena B (Thread-specific) | | +-----------------------------+ | | | Memory Blocks | | | +-----------------------------+ | +----------------------------------+ Thread C +----------------------------------+ | Arena C (Thread-specific) | | +-----------------------------+ | | | Memory Blocks | | | +-----------------------------+ | +----------------------------------+ Chunks A chunk refers to a contiguous block of memory managed by the allocator. Chunks are the fundamental units of memory that malloc manages and allocates to the program\nStrurture of malloc chunk struct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; Whenever you call the malloc function to allocate some block of memory it simply allocate that memory and return a pointer to that allocated memory area but in reality the actual size of the chunk is grater then the requested size of the chunk. This is because the allocator need to store some metadata for managing the heap.\nFor example you requested 16 bytes of memory malloc(0x10) so the allocator will add some extra bytes to store the metadata in case of 64bit system it is 16 bytes so the actual size of the chunk is going to be :: 16 bytes(requested size) + 16 bytes(metadata) = 32 bytes(actual allocation size)\nFor 32 bit system the size will be :: 16 bytes(requested size) + 8 bytes(metadata) = 24 bytes(actual allocation size)\nChunk Metadata An allocated chunk looks like this: chunk-\u003e +-------------------------------------------+ | Size of previous chunk, if unallocated | \u003c-- 4 or 8 bytes +-------------------------------------------+ | Size of chunk, in bytes |A|M|P| \u003c-- 4 or 8 bytes mem-\u003e +-------------------------------------------+ | User data starts here... | \u003c-- malloc_usable_size() bytes . . . . . | nextchunk-\u003e +-------------------------------------------+ | (size of chunk, but used for application) | \u003c-- 4 or 8 bytes +-------------------------------------------+ | Size of next chunk, in bytes |A|0|1| \u003c-- 4 or 8 bytes +-------------------------------------------+ Each chunk begins with a field that stores the size of the previous chunk, but only if the previous chunk is unallocated. This size field is either 4 or 8 bytes, depending on the system architecture. This field helps in coalescing adjacent free chunks to reduce fragmentation.\nThe next field is the size of the current chunk, which also includes the size of its own header. This field is also either 4 or 8 bytes. Besides storing the chunk size, the least significant three bits of this field are used as flags: A, M, and P\nA (Allocated), M (Mmap), P (Previous In Use) bit fields.*\nThe A bit, found as the least significant bit of a chunk’s size field, tells whether the chunk is currently in use (1) or free (0). It’s crucial for quickly checking if memory is available for allocation or if it’s already allocated by the program.\nThe M bit, the second least significant bit, distinguishes chunks allocated via mmap (1) from those managed by the heap (0). mmap is used for larger allocations to prevent heap fragmentation by managing memory differently from typical heap allocations\nThe P bit, located as the third least significant bit, indicates if the previous chunk in memory is allocated (1) or free (0). This helps in merging adjacent free chunks to reduce fragmentation and optimize memory usage in the heap.\nAfter the metadata fields, the chunk contains space for user data. The size of this area is determined by the malloc_usable_size() function, which tells us how much space is available for the application to store its data. This is where programs store the information they need to work with.\nAfter the user data section lies the beginning of the next chunk in memory. This subsequent chunk starts with a field that serves dual purposes: it holds the size of this next chunk and, just like the current chunk’s size field, its least significant bits are used as flags. Specifically, these flags include the A flag (Allocated) indicating if the next chunk is allocated (1) or free (0), and the P flag (Previous In Use) to show if the current chunk is in use (1)\nBins The glibc memory allocator organizes free memory chunks into various bins to optimize allocation and deallocation operations. These bins—Fastbins, Tcache bins, Small bins, and Large bins—differ in their structure, usage, and efficiency, and each type has a specific number of bins designed to handle different chunk sizes.\nSmall bins handle chunks that are between 65 bytes and 512 bytes and are managed as doubly linked lists using both fd (forward) and bk (backward) pointers. There are 62 Small bins, each corresponding to a specific size class. The use of doubly linked lists allows efficient traversal and management of free chunks, although it introduces more complexity compared to the simpler Fastbins and Tcache bins.\nSmall Bins ( 65 bytes to 512 bytes) +--------------+ | Smallbin[0] | +--------------+ | v +-------------+ \u003c--\u003e +-------------+ \u003c--\u003e +-------------+ | Chunk (fd) | | Chunk (fd) | | Chunk (fd) | \u003c--\u003e NULL | Size A | | Size A | | Size A | +-------------+ +-------------+ +-------------+ | ... | +-------------+ | Smallbin[63]| +-------------+ | v +-------------+ \u003c--\u003e NULL | Chunk (fd) | | Size B | +-------------+ Fastbins are designed for very quick allocation and deallocation of small chunks, typically up to 64 bytes. Managed as singly linked lists using the fd (forward) pointer, there are 10 Fastbins (usually indexed from 0 to 9) in the array, each corresponding to a specific size class. When a chunk of memory is freed, it is added to the appropriate Fastbin list, making it available for rapid reallocation.\nFastbins ( \u003c= 64 bytes) +------------+ | Fastbin[0] | +------------+ | v +-------------+ +-------------+ +-------------+ | Chunk (fd) | ---\u003e | Chunk (fd) | ---\u003e | Chunk (fd) | ---\u003e NULL | Size A | | Size A | | Size A | +-------------+ +-------------+ +-------------+ | ... | | ... | | ... | +-------------+ +-------------+ +-------------+ | Fastbin[7] | +-------------+ | v +-------------+ +-------------+ | Chunk (fd) | ---\u003e | Chunk (fd) | ---\u003e NULL | Size B | | Size B | +-------------+ +-------------+ Large bins are used for chunks larger than 512 bytes and are also managed as doubly linked lists with fd and bk pointers. There are 63 Large bins, with each entry in the Largebin array corresponding to a range of chunk sizes rather than a specific size class. This approach is necessary to efficiently manage larger chunks of memory, but it also means that operations involving Large bins are typically slower and more complex due to the need to maintain sorted order and manage larger memory areas.\nLarge Bins ( \u003e 512 bytes) +--------------+ | Largebin[0] | +--------------+ | v +-------------+ \u003c--\u003e +-------------+ | Chunk (fd) | | Chunk (fd) | \u003c--\u003e NULL | Size A | | Size A | +-------------+ +-------------+ | ... | +-------------+ |Largebin[127]| +-------------+ | v +-------------+ \u003c--\u003e NULL | Chunk (fd) | | Size B | +-------------+ Tcache bins also use singly linked lists with the fd pointer but are stored in thread-local storage to improve performance and reduce contention. There are 64 Tcache bins, each corresponding to a specific size class, similar to Fastbins, but they can hold a limited number of chunks (typically 64 per bin). This caching mechanism speeds up allocation and deallocation operations by avoiding global locks and directly accessing recently freed chunks within the same thread.\nTcache Bins ( \u003c= 64 bytes) +------------+ | Tcache[0] | +------------+ | v +-------------+ +-------------+ | Chunk (fd) | ---\u003e | Chunk (fd) | ---\u003e NULL | Size A | | Size A | +-------------+ +-------------+ | ... | +-------------+ | Tcache[63] | +-------------+ | v +-------------+ | Chunk (fd) | ---\u003e NULL | Size B | +-------------+ Unsorted bins serve as a temporary holding area for freed chunks before they are placed into the appropriate Small or Large bin. Managed as doubly linked lists with fd and bk pointers, there is only one Unsorted bin. When a chunk is freed, it is initially placed in the Unsorted bin. Later, during memory allocation, chunks from the Unsorted bin are sorted and placed into the appropriate bin based on their size. This mechanism helps to reduce fragmentation and improve the efficiency of memory allocation.\nFragmentation Heap fragmentation refers to the phenomenon where memory becomes divided into small, unusable pieces over time due to allocations and deallocations. This fragmentation can occur in both the heap managed by the operating system and within individual memory arenas managed by allocators like ptmalloc in GLIBC\nConsolidation Consolidation in the heap, refers to the process of combining fragmented memory blocks into larger contiguous blocks. This process helps reduce external fragmentation and improves the efficiency of memory usage.\nReference https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/\nhttps://pwn.college/software-exploitation/dynamic-allocator-misuse/\nhttps://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c\nhttps://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/\nhttps://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/\nhttps://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/\nhttps://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8\nhttps://en.wikipedia.org/wiki/C_dynamic_memory_allocation#dlmalloc_and_ptmalloc\n",
  "wordCount" : "2378",
  "inLanguage": "en",
  "datePublished": "2024-06-10T00:00:00Z",
  "dateModified": "2024-06-10T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Mr_N1"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/heapexp1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mr_N₁gativ3",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Mr_N₁gativ3 (Alt + H)">Mr_N₁gativ3</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Heap Exploitation Part 1
    </h1>
    <div class="post-description">
      Exploring GLIBC Heap
    </div>
    <div class="post-meta"><span title='2024-06-10 00:00:00 +0000 UTC'>June 10, 2024</span>&nbsp;·&nbsp;<span>12 min</span>&nbsp;·&nbsp;<span>Mr_N1</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#what-is-heap-and-why" aria-label="What is Heap and Why?">What is Heap and Why?</a></li>
                <li>
                    <a href="#history-of-dynamic-memory-allocator" aria-label="History of Dynamic Memory Allocator">History of Dynamic Memory Allocator</a></li>
                <li>
                    <a href="#arenas" aria-label="Arenas">Arenas</a></li>
                <li>
                    <a href="#chunks" aria-label="Chunks">Chunks</a></li>
                <li>
                    <a href="#chunk-metadata" aria-label="Chunk Metadata">Chunk Metadata</a></li>
                <li>
                    <a href="#bins" aria-label="Bins">Bins</a></li>
                <li>
                    <a href="#fragmentation" aria-label="Fragmentation">Fragmentation</a></li>
                <li>
                    <a href="#consolidation" aria-label="Consolidation">Consolidation</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="intro"><strong>Intro</strong><a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h2>
<p>This is the first part of the heap exploitation series in this post i will give you an basic overview of glibc heap implementation and discuss about some basic terminologies and in the upcoming post we will take a look at how the memory allocation takes place and how it gets free and further we will look at different heap related vulnerabilities and see how to exploit them.</p>
<hr>
<h2 id="what-is-heap-and-why"><strong>What is Heap and Why?</strong><a hidden class="anchor" aria-hidden="true" href="#what-is-heap-and-why">#</a></h2>
<p>Heap is a type of memory used in programs to store data that needs to be dynamically allocated and can change in size during the program&rsquo;s execution. The programmer can request chunk of memory from the heap and the heap manager will allocate that chunk to the program. To request a chunk of memory on heap we use <em><strong>malloc</strong></em> function and provide the size of memory that we need and it will return a pointer to that allocated chunk and using <em><strong>free</strong></em> function we can deallocate that chunk form the heap. It is very effective method for allocating memory which lives in a program for long period time and the size of the memory can be expended when its fully exhausted. You can do that using <a href="https://linux.die.net/man/2/sbrk"><em><strong>sbrk</strong></em></a> or <a href="https://man7.org/linux/man-pages/man2/mmap.2.html"><em><strong>mmap</strong></em></a> system call and when the memory is no longer needed you can free it.</p>
<p><em><strong>You may be wondering why don’t we use stack it also get’s the job done.</strong></em></p>
<p>Think about a scenario where you have a dynamic game in which there are multiple items and your player collect those items and the size of its inventory grow. Using the heap, you can easily expand the inventory array as needed without worrying about the fixed size limitations of the stack.</p>
<p><strong>OR</strong></p>
<p>When the player enters a new area in the game, you might need to create 100 new enemy objects. Allocating these on the stack could quickly exhaust stack space, leading to stack overflow. The heap, on the other hand, can handle such allocations more gracefully. In some case some enemies often need to alive for entire game or for some specific amount of time. The stack is unsuitable for such long-lived objects as it is designed for temporary storage within function calls. which means when the function exits the memory allocated for those variable will be reclaimed by the stack.</p>
<hr>
<p><em><strong>Memory layout example of x86-64 architecture</strong></em></p>
<ul>
<li>On a 64-bit Linux system, the stack might start at around <code>0x7fffffffffff</code> and grow downwards</li>
<li>Heap might start at around <code>0x600000000000</code> on a 64-bit system and grow upwards</li>
<li>BSS segment addresses might be in the lower range, just above the data segment.</li>
<li>Data segment Typically located just above the code segment</li>
<li>Code segment might start at a fixed low address, such as <code>0x00400000</code> on a 64-bit Linux system</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">High Memory Addresses        
</span></span><span class="line"><span class="cl">      +------------------+   
</span></span><span class="line"><span class="cl">      |      Stack       |    0x7fffffffffff {Top of stack}
</span></span><span class="line"><span class="cl">      |        |         |
</span></span><span class="line"><span class="cl">      |        v         |
</span></span><span class="line"><span class="cl">      |                  |
</span></span><span class="line"><span class="cl">      | (grows downward) |
</span></span><span class="line"><span class="cl">      +------------------+
</span></span><span class="line"><span class="cl">      |                  |
</span></span><span class="line"><span class="cl">      |        ^         |
</span></span><span class="line"><span class="cl">      |        |         |
</span></span><span class="line"><span class="cl">      |       Heap       |
</span></span><span class="line"><span class="cl">      | (grows upward)   |    0x600000000000 {Start of heap}
</span></span><span class="line"><span class="cl">      +------------------+
</span></span><span class="line"><span class="cl">      |   BSS Segment    |
</span></span><span class="line"><span class="cl">      +------------------+
</span></span><span class="line"><span class="cl">      |   Data Segment   |
</span></span><span class="line"><span class="cl">      +------------------+
</span></span><span class="line"><span class="cl">      |   Code Segment   |    0x00400000 {Start of code segment}
</span></span><span class="line"><span class="cl">      +------------------+   
</span></span><span class="line"><span class="cl">Low Memory Addresses
</span></span></code></pre></div><hr>
<h2 id="history-of-dynamic-memory-allocator"><strong>History of Dynamic Memory Allocator</strong><a hidden class="anchor" aria-hidden="true" href="#history-of-dynamic-memory-allocator">#</a></h2>
<p>Memory allocators are fundamental components of modern computer systems, responsible for managing dynamic memory allocation and deallocation. Over the years, several allocators have been developed, each optimized for different use cases and performance scenarios.</p>
<p>One of the earliest and most influential memory allocators was <strong>dlmalloc</strong>, developed by Doug Lea in 1987. Initially designed as a general-purpose allocator, dlmalloc became widely used due to its efficiency and portability across different systems.</p>
<p>In the early days of Linux and Unix-like systems, <strong>dlmalloc</strong> (Doug Lea&rsquo;s malloc) was indeed one of the most commonly used memory allocators due to its efficiency and portability. However, the transition to <strong>ptmalloc</strong> (POSIX threads malloc) was driven by the need to support multi-threaded applications more effectively.</p>
<p>The current memory allocater used in linux is <strong>ptmalloc3</strong> it is an evolution of the ptmalloc (POSIX threads malloc) allocator, which itself is a fork of Doug Lea&rsquo;s original dlmalloc. ptmalloc3 represents a significant enhancement over its predecessors, focusing on improving performance and scalability for multi-threaded applications.</p>
<p><em>There are several other memory allocators created and used by different platforms</em></p>
<blockquote>
<p><strong>jemalloc</strong> initially created for FreeBSD, offers scalable multi-threaded memory allocation</p></blockquote>
<blockquote>
<p><strong>tcmalloc</strong> (Thread-Caching malloc), developed by Google, is optimized for performance in multi-threaded environments</p></blockquote>
<blockquote>
<p><strong>mimalloc</strong> introduced by Microsoft, focuses on compact memory usage, low latency, and high concurrency.</p></blockquote>
<hr>
<h2 id="arenas"><strong>Arenas</strong><a hidden class="anchor" aria-hidden="true" href="#arenas">#</a></h2>
<p>Arenas in ptmalloc are dedicated memory management regions assigned to individual threads within the GLIBC heap allocator. Each thread that interacts with the heap is associated with its own arena. This design allows threads to perform memory allocations and deallocations independently, minimizing contention and improving performance in multi-threaded applications. Arenas manage memory blocks and metadata specific to each thread, optimizing memory usage and reducing synchronization overhead. When a thread requests memory from the heap, it interacts solely with its designated arena, ensuring efficient and scalable memory management across concurrent threads. Multiple arenas can exist simultaneously, dynamically created and managed by ptmalloc based on the application&rsquo;s threading requirements.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">   Thread A
</span></span><span class="line"><span class="cl">   +----------------------------------+
</span></span><span class="line"><span class="cl">   |  Arena A (Thread-specific)        |
</span></span><span class="line"><span class="cl">   |  +-----------------------------+  |
</span></span><span class="line"><span class="cl">   |  |         Memory Blocks       |  |
</span></span><span class="line"><span class="cl">   |  +-----------------------------+  |
</span></span><span class="line"><span class="cl">   +----------------------------------+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   Thread B
</span></span><span class="line"><span class="cl">   +----------------------------------+
</span></span><span class="line"><span class="cl">   |  Arena B (Thread-specific)        |
</span></span><span class="line"><span class="cl">   |  +-----------------------------+  |
</span></span><span class="line"><span class="cl">   |  |         Memory Blocks       |  |
</span></span><span class="line"><span class="cl">   |  +-----------------------------+  |
</span></span><span class="line"><span class="cl">   +----------------------------------+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   Thread C
</span></span><span class="line"><span class="cl">   +----------------------------------+
</span></span><span class="line"><span class="cl">   |  Arena C (Thread-specific)        |
</span></span><span class="line"><span class="cl">   |  +-----------------------------+  |
</span></span><span class="line"><span class="cl">   |  |         Memory Blocks       |  |
</span></span><span class="line"><span class="cl">   |  +-----------------------------+  |
</span></span><span class="line"><span class="cl">   +----------------------------------+
</span></span></code></pre></div><hr>
<h2 id="chunks"><strong>Chunks</strong><a hidden class="anchor" aria-hidden="true" href="#chunks">#</a></h2>
<blockquote>
<p>A chunk refers to a contiguous block of memory managed by the allocator. Chunks are the fundamental units of memory that <code>malloc</code> manages and allocates to the program</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">Strurture of malloc chunk
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct malloc_chunk {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
</span></span><span class="line"><span class="cl">  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  struct malloc_chunk* fd;         /* double links -- used only if free. */
</span></span><span class="line"><span class="cl">  struct malloc_chunk* bk;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  /* Only used for large blocks: pointer to next larger size.  */
</span></span><span class="line"><span class="cl">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
</span></span><span class="line"><span class="cl">  struct malloc_chunk* bk_nextsize;
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></div><p>Whenever you call the malloc function to allocate some block of memory it simply allocate that memory and return a pointer to that allocated memory area but in reality the actual size of the chunk is grater then the requested size of the chunk. This is because the allocator need to store some metadata for managing the heap.</p>
<blockquote>
<p><em>For example you requested 16 bytes of memory <strong>malloc(0x10)</strong> so the allocator will add some extra bytes to store the metadata in case of 64bit system it is 16 bytes so the actual size of the chunk is going to be  :: 16 bytes(requested size) + 16 bytes(metadata) = 32 bytes(actual allocation size)</em></p></blockquote>
<blockquote>
<p><em>For 32 bit system the size will be  ::  16 bytes(requested size) + 8 bytes(metadata) = 24 bytes(actual allocation size)</em></p></blockquote>
<h2 id="chunk-metadata"><strong>Chunk Metadata</strong><a hidden class="anchor" aria-hidden="true" href="#chunk-metadata">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">An allocated chunk looks like this:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">chunk-&gt;     +-------------------------------------------+
</span></span><span class="line"><span class="cl">            | Size of previous chunk, if unallocated    | <span class="p">&lt;</span><span class="nt">--</span> <span class="na">4</span> <span class="na">or</span> <span class="na">8</span> <span class="na">bytes</span>
</span></span><span class="line"><span class="cl">            <span class="err">+</span><span class="na">-------------------------------------------</span><span class="err">+</span>
</span></span><span class="line"><span class="cl">            <span class="err">|</span> <span class="na">Size</span> <span class="na">of</span> <span class="na">chunk</span><span class="err">,</span> <span class="na">in</span> <span class="na">bytes</span>             <span class="err">|</span><span class="na">A</span><span class="err">|</span><span class="na">M</span><span class="err">|</span><span class="na">P</span><span class="err">|</span>  <span class="err">&lt;</span><span class="na">--</span> <span class="na">4</span> <span class="na">or</span> <span class="na">8</span> <span class="na">bytes</span>
</span></span><span class="line"><span class="cl"><span class="na">mem-</span><span class="p">&gt;</span>       +-------------------------------------------+
</span></span><span class="line"><span class="cl">            | User data starts here...                  | <span class="p">&lt;</span><span class="nt">--</span> <span class="na">malloc_usable_size</span><span class="err">()</span> <span class="na">bytes</span>
</span></span><span class="line"><span class="cl">            <span class="err">.</span>                                           <span class="err">.</span>
</span></span><span class="line"><span class="cl">            <span class="err">.</span>                                           <span class="err">.</span>
</span></span><span class="line"><span class="cl">            <span class="err">.</span>                                           <span class="err">|</span>
</span></span><span class="line"><span class="cl"><span class="na">nextchunk-</span><span class="p">&gt;</span> +-------------------------------------------+
</span></span><span class="line"><span class="cl">            | (size of chunk, but used for application) |  <span class="p">&lt;</span><span class="nt">--</span> <span class="na">4</span> <span class="na">or</span> <span class="na">8</span> <span class="na">bytes</span>
</span></span><span class="line"><span class="cl">            <span class="err">+</span><span class="na">-------------------------------------------</span><span class="err">+</span>
</span></span><span class="line"><span class="cl">            <span class="err">|</span> <span class="na">Size</span> <span class="na">of</span> <span class="na">next</span> <span class="na">chunk</span><span class="err">,</span> <span class="na">in</span> <span class="na">bytes</span>        <span class="err">|</span><span class="na">A</span><span class="err">|</span><span class="na">0</span><span class="err">|</span><span class="na">1</span><span class="err">|</span>  <span class="err">&lt;</span><span class="na">--</span> <span class="na">4</span> <span class="na">or</span> <span class="na">8</span> <span class="na">bytes</span>
</span></span><span class="line"><span class="cl">            <span class="err">+</span><span class="na">-------------------------------------------</span><span class="err">+</span>
</span></span></code></pre></div><p>Each chunk begins with a field that stores the size of the previous chunk, but only if the previous chunk is unallocated. This size field is either 4 or 8 bytes, depending on the system architecture. This field helps in coalescing adjacent free chunks to reduce fragmentation.</p>
<p>The next field is the size of the current chunk, which also includes the size of its own header. This field is also either 4 or 8 bytes. Besides storing the chunk size, the least significant three bits of this field are used as flags: <code>A</code>, <code>M</code>, and <code>P</code></p>
<p><strong>A</strong> (Allocated), <strong>M</strong> (Mmap), <strong>P</strong> (Previous In Use) bit fields.*</p>
<blockquote>
<p>The <code>A</code> bit, found as the least significant bit of a chunk&rsquo;s size field, tells whether the chunk is currently in use (<code>1</code>) or free (<code>0</code>). It&rsquo;s crucial for quickly checking if memory is available for allocation or if it&rsquo;s already allocated by the program.</p></blockquote>
<blockquote>
<p>The <code>M</code> bit, the second least significant bit, distinguishes chunks allocated via <code>mmap</code> (<code>1</code>) from those managed by the heap (<code>0</code>). <code>mmap</code> is used for larger allocations to prevent heap fragmentation by managing memory differently from typical heap allocations</p></blockquote>
<blockquote>
<p>The <code>P</code> bit, located as the third least significant bit, indicates if the previous chunk in memory is allocated (<code>1</code>) or free (<code>0</code>). This helps in merging adjacent free chunks to reduce fragmentation and optimize memory usage in the heap.</p></blockquote>
<p>After the metadata fields, the chunk contains space for user data. The size of this area is determined by the <code>malloc_usable_size()</code> function, which tells us how much space is available for the application to store its data. This is where programs store the information they need to work with.</p>
<p>After the user data section lies the beginning of the next chunk in memory. This subsequent chunk starts with a field that serves dual purposes: it holds the size of this next chunk and, just like the current chunk&rsquo;s size field, its least significant bits are used as flags. Specifically, these flags include the <code>A</code> flag (Allocated) indicating if the next chunk is allocated (1) or free (0), and the <code>P</code> flag (Previous In Use) to show if the current chunk is in use (1)</p>
<hr>
<h2 id="bins"><strong>Bins</strong><a hidden class="anchor" aria-hidden="true" href="#bins">#</a></h2>
<p>The glibc memory allocator organizes free memory chunks into various bins to optimize allocation and deallocation operations. These bins—Fastbins, Tcache bins, Small bins, and Large bins—differ in their structure, usage, and efficiency, and each type has a specific number of bins designed to handle different chunk sizes.</p>
<p><em><strong>Small bins</strong></em> handle chunks that are between 65 bytes and 512 bytes and are managed as doubly linked lists using both <code>fd</code> (forward) and <code>bk</code> (backward) pointers. There are 62 Small bins, each corresponding to a specific size class. The use of doubly linked lists allows efficient traversal and management of free chunks, although it introduces more complexity compared to the simpler Fastbins and Tcache bins.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">Small Bins ( 65 bytes to 512 bytes)
</span></span><span class="line"><span class="cl">+--------------+
</span></span><span class="line"><span class="cl">| Smallbin[0]  |
</span></span><span class="line"><span class="cl">+--------------+
</span></span><span class="line"><span class="cl">       |
</span></span><span class="line"><span class="cl">       v
</span></span><span class="line"><span class="cl">+-------------+ <span class="p">&lt;</span><span class="nt">--</span><span class="p">&gt;</span> +-------------+ <span class="p">&lt;</span><span class="nt">--</span><span class="p">&gt;</span> +-------------+
</span></span><span class="line"><span class="cl">| Chunk (fd)  |      | Chunk (fd)  |      | Chunk (fd)  | <span class="p">&lt;</span><span class="nt">--</span><span class="p">&gt;</span> NULL
</span></span><span class="line"><span class="cl">|  Size A     |      |  Size A     |      |  Size A     |
</span></span><span class="line"><span class="cl">+-------------+      +-------------+      +-------------+
</span></span><span class="line"><span class="cl">|   ...       |
</span></span><span class="line"><span class="cl">+-------------+
</span></span><span class="line"><span class="cl">| Smallbin[63]|
</span></span><span class="line"><span class="cl">+-------------+
</span></span><span class="line"><span class="cl">       |
</span></span><span class="line"><span class="cl">       v
</span></span><span class="line"><span class="cl">+-------------+ <span class="p">&lt;</span><span class="nt">--</span><span class="p">&gt;</span> NULL
</span></span><span class="line"><span class="cl">| Chunk (fd)  |
</span></span><span class="line"><span class="cl">|  Size B     |
</span></span><span class="line"><span class="cl">+-------------+
</span></span></code></pre></div><p><em><strong>Fastbins</strong></em> are designed for very quick allocation and deallocation of small chunks, typically up to 64 bytes. Managed as singly linked lists using the <code>fd</code> (forward) pointer, there are 10 Fastbins (usually indexed from 0 to 9) in the array, each corresponding to a specific size class. When a chunk of memory is freed, it is added to the appropriate Fastbin list, making it available for rapid reallocation.</p>
<pre tabindex="0"><code>Fastbins ( &lt;= 64 bytes)
+------------+
| Fastbin[0] |
+------------+
       |
       v
+-------------+      +-------------+      +-------------+
| Chunk (fd)  | ---&gt; | Chunk (fd)  | ---&gt; | Chunk (fd)  | ---&gt; NULL
|  Size A     |      |  Size A     |      |  Size A     |
+-------------+      +-------------+      +-------------+
|   ...       |      |   ...       |      |   ...       |
+-------------+      +-------------+      +-------------+
| Fastbin[7]  |
+-------------+
       |
       v
+-------------+      +-------------+
| Chunk (fd)  | ---&gt; | Chunk (fd)  | ---&gt; NULL
|  Size B     |      |  Size B     |
+-------------+      +-------------+
</code></pre><p><em><strong>Large bins</strong></em> are used for chunks larger than 512 bytes and are also managed as doubly linked lists with <code>fd</code> and <code>bk</code> pointers. There are 63 Large bins, with each entry in the Largebin array corresponding to a range of chunk sizes rather than a specific size class. This approach is necessary to efficiently manage larger chunks of memory, but it also means that operations involving Large bins are typically slower and more complex due to the need to maintain sorted order and manage larger memory areas.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">Large Bins ( &gt; 512 bytes)
</span></span><span class="line"><span class="cl">+--------------+
</span></span><span class="line"><span class="cl">| Largebin[0]  |
</span></span><span class="line"><span class="cl">+--------------+
</span></span><span class="line"><span class="cl">       |
</span></span><span class="line"><span class="cl">       v
</span></span><span class="line"><span class="cl">+-------------+ <span class="p">&lt;</span><span class="nt">--</span><span class="p">&gt;</span> +-------------+
</span></span><span class="line"><span class="cl">| Chunk (fd)  |      | Chunk (fd)  | <span class="p">&lt;</span><span class="nt">--</span><span class="p">&gt;</span> NULL
</span></span><span class="line"><span class="cl">|  Size A     |      |  Size A     |
</span></span><span class="line"><span class="cl">+-------------+      +-------------+
</span></span><span class="line"><span class="cl">|   ...       |
</span></span><span class="line"><span class="cl">+-------------+
</span></span><span class="line"><span class="cl">|Largebin[127]|
</span></span><span class="line"><span class="cl">+-------------+
</span></span><span class="line"><span class="cl">       |
</span></span><span class="line"><span class="cl">       v
</span></span><span class="line"><span class="cl">+-------------+ <span class="p">&lt;</span><span class="nt">--</span><span class="p">&gt;</span> NULL
</span></span><span class="line"><span class="cl">| Chunk (fd)  |
</span></span><span class="line"><span class="cl">|  Size B     |
</span></span><span class="line"><span class="cl">+-------------+
</span></span></code></pre></div><p><em><strong>Tcache bins</strong></em> also use singly linked lists with the <code>fd</code> pointer but are stored in thread-local storage to improve performance and reduce contention. There are 64 Tcache bins, each corresponding to a specific size class, similar to Fastbins, but they can hold a limited number of chunks (typically 64 per bin). This caching mechanism speeds up allocation and deallocation operations by avoiding global locks and directly accessing recently freed chunks within the same thread.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">Tcache Bins ( <span class="err">&lt;</span>= 64 bytes)
</span></span><span class="line"><span class="cl">+------------+
</span></span><span class="line"><span class="cl">| Tcache[0]  |
</span></span><span class="line"><span class="cl">+------------+
</span></span><span class="line"><span class="cl">       |
</span></span><span class="line"><span class="cl">       v
</span></span><span class="line"><span class="cl">+-------------+      +-------------+
</span></span><span class="line"><span class="cl">| Chunk (fd)  | ---&gt; | Chunk (fd)  | ---&gt; NULL
</span></span><span class="line"><span class="cl">|  Size A     |      |  Size A     |
</span></span><span class="line"><span class="cl">+-------------+      +-------------+
</span></span><span class="line"><span class="cl">|   ...       |
</span></span><span class="line"><span class="cl">+-------------+
</span></span><span class="line"><span class="cl">| Tcache[63]  |
</span></span><span class="line"><span class="cl">+-------------+
</span></span><span class="line"><span class="cl">       |
</span></span><span class="line"><span class="cl">       v
</span></span><span class="line"><span class="cl">+-------------+
</span></span><span class="line"><span class="cl">| Chunk (fd)  | ---&gt; NULL
</span></span><span class="line"><span class="cl">|  Size B     |
</span></span><span class="line"><span class="cl">+-------------+
</span></span></code></pre></div><p><em><strong>Unsorted bins</strong></em> serve as a temporary holding area for freed chunks before they are placed into the appropriate Small or Large bin. Managed as doubly linked lists with <code>fd</code> and <code>bk</code> pointers, there is only one Unsorted bin. When a chunk is freed, it is initially placed in the Unsorted bin. Later, during memory allocation, chunks from the Unsorted bin are sorted and placed into the appropriate bin based on their size. This mechanism helps to reduce fragmentation and improve the efficiency of memory allocation.</p>
<hr>
<h2 id="fragmentation"><strong>Fragmentation</strong><a hidden class="anchor" aria-hidden="true" href="#fragmentation">#</a></h2>
<p>Heap fragmentation refers to the phenomenon where memory becomes divided into small, unusable pieces over time due to allocations and deallocations. This fragmentation can occur in both the heap managed by the operating system and within individual memory arenas managed by allocators like ptmalloc in GLIBC</p>
<h2 id="consolidation"><strong>Consolidation</strong><a hidden class="anchor" aria-hidden="true" href="#consolidation">#</a></h2>
<p>Consolidation in the heap, refers to the process of combining fragmented memory blocks into larger contiguous blocks. This process helps reduce external fragmentation and improves the efficiency of memory usage.</p>
<br>
Reference
<hr>
<p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a></p>
<p><a href="https://pwn.college/software-exploitation/dynamic-allocator-misuse/">https://pwn.college/software-exploitation/dynamic-allocator-misuse</a>/</p>
<p><a href="https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c#L53">https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c</a></p>
<p><a href="https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/">https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/</a></p>
<p><a href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/">https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/</a></p>
<p><a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/</a></p>
<p><a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8</a></p>
<p><a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#dlmalloc_and_ptmalloc">https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#dlmalloc_and_ptmalloc</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/heapexp2/">
    <span class="title">« Prev</span>
    <br>
    <span>Heap Exploitation Part 2</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 1 on x"
            href="https://x.com/intent/tweet/?text=Heap%20Exploitation%20Part%201&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp1%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 1 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp1%2f&amp;title=Heap%20Exploitation%20Part%201&amp;summary=Heap%20Exploitation%20Part%201&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 1 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp1%2f&title=Heap%20Exploitation%20Part%201">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 1 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 1 on whatsapp"
            href="https://api.whatsapp.com/send?text=Heap%20Exploitation%20Part%201%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp1%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 1 on telegram"
            href="https://telegram.me/share/url?text=Heap%20Exploitation%20Part%201&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp1%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 1 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Heap%20Exploitation%20Part%201&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp1%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Mr_N₁gativ3</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
