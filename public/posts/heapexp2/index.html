<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Heap Exploitation Part 2 | Mr_N₁gativ3</title>
<meta name="keywords" content="">
<meta name="description" content="Memory Allocation and Deallocation Process">
<meta name="author" content="Mr_N1">
<link rel="canonical" href="http://localhost:1313/posts/heapexp2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2846fd1f2998a1fa9b915df960aef781eb2a0bd48e18d1d90d158327a491a7a3.css" integrity="sha256-KEb9HymYofqbkV35YK73gesqC9SOGNHZDRWDJ6SRp6M=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/heapexp2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/posts/heapexp2/">
  <meta property="og:site_name" content="Mr_N₁gativ3">
  <meta property="og:title" content="Heap Exploitation Part 2">
  <meta property="og:description" content="Memory Allocation and Deallocation Process">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-08-16T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Heap Exploitation Part 2">
<meta name="twitter:description" content="Memory Allocation and Deallocation Process">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Heap Exploitation Part 2",
      "item": "http://localhost:1313/posts/heapexp2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Heap Exploitation Part 2",
  "name": "Heap Exploitation Part 2",
  "description": "Memory Allocation and Deallocation Process",
  "keywords": [
    
  ],
  "articleBody": "Intro Welcome back to the second part of the Heap Exploitation Series. In the previous part, I provided a basic overview of glibc’s heap implementation. If you haven’t read that part yet, I highly recommend you go back and check it out to understand fundamental concepts such as chunks and bins. However, if you are already familiar with these basics, you can continue reading here. In this post, we will delve deeper into the process of memory allocation and deallocation in glibc’s heap. We’ll explore how memory is allocated for a process and the mechanisms involved in freeing memory.\nBasics Memory Allocation When you request memory for your program, for example, 0x10 bytes of memory, by calling malloc, it returns a pointer to the allocated memory space where you can store your data. However, the allocation process involves more than simply providing 16 bytes of free memory space.\nThe heap manager performs several additional tasks behind the scenes. It keeps track of all allocated memory chunks by storing metadata alongside the user-requested space. This metadata includes information such as the size of the allocated chunk and its status (e.g., whether it is free or in use). Additionally, the heap manager ensures proper memory alignment for better efficiency. On 32-bit systems, memory is typically aligned to 0x8 (8) bytes, while on 64-bit systems, it is aligned to 0x10 (16) bytes.\nWhen you request 0x10 (16) bytes of memory, the heap manager actually allocates more than just 16 bytes. In practice, it typically allocates a total of 32 bytes. This allocation includes 16 bytes for metadata or a header, which contains information about the allocated chunk, such as its size and status. Additionally, it includes the 16 bytes you requested for storing your data. To ensure proper alignment, particularly on 64-bit systems where memory is aligned to 16-byte blocks, 6 bytes of padding are added. This padding ensures that the memory allocation is aligned correctly, making the total allocated memory 32 bytes, accommodating both the user-requested space and the necessary overhead for metadata and alignment.\nRequested Size: 10 bytes Total Without Alignment: 10 + 16 = 26 bytes Alignment Padding: To align to 16 bytes, we need 6 more bytes to reach 32 bytes Total Allocated Size: 32 bytes Overhead: 32 - 10 = 22 bytes Allocated Chunk Example\nAfter that heap manager mark this chunk as allocated and returns a pointer to the “User Data” region inside the chunk. which is the same return pointer you get from the malloc after the memory allocation.\nChunk Allocation Before Talking about how a Chunk is allocated lets talk about how a heap is created in the first place\nWhen malloc is called for the first time, the heap manager initiates the creation of the heap segment for the program. Initially, the operating system does not allocate any memory for the heap, but when the first memory allocation request is made, the heap manager uses system calls such as brk or sbrk to adjust the program break, effectively expanding the heap segment by allocating additional memory from the operating system. If the request is for a large amount of memory, the heap manager may use mmap to map a new memory region directly. The heap manager then initializes its internal data structures, such as free lists or bins, to manage the newly allocated heap space. This setup allows the heap to handle subsequent memory allocation and deallocation requests efficiently.\nNow lets see how the heap manager allocates the chunks.\nThere are various way a memory chunk can be allocated.\nAllocation From Free List (bins) Allocation From Top Chunk Requesting Kernel For Extra Heap Memory Using mmap for Larger Allocation Allocation From Free Lists (Bins) The heap manager has multiple free lists, also known as bins. These bins store all the chunks that are freed. The freed chunks are stored in different lists based on their size. For example, chunks larger than 512 bytes are stored in the large bin.\nWhen you request memory from the heap manager, it will search through the bins and try to find a free chunk that can fit the requested size. If the heap manager finds a chunk that is big enough to fulfill your allocation request, it will mark that chunk as allocated and return a pointer to the “User Data” area to the program. After that chunk is no longer in use and gets freed, the heap manager will add that chunk back to the free list (bin).\nAllocation From Top Chunk The top chunk is a unique feature of the GLIBC memory allocator. It represents the last free chunk in the heap and is notable for being the largest among all the chunks. This chunk can be dynamically expanded as needed. There is only one top chunk in the entire heap. If the heap manager fails to find a suitable free chunk that matches desired allocation request, then it will create a new chunk from the top chunk and resize the top chunk accordingly and allocate that newly create chunk to the program.\nRequesting Kernel For Extra Heap Memory When the heap memory is fully exhausted or there is insufficient memory available at the top chunk to allocate a large-sized chunk, the heap manager requests the kernel to add more memory to the heap, expanding its size. The heap manager expands heap memory using the sbrk system call by adjusting the program break, which defines the end of the heap. When a program requests more memory than is available within the current heap, the heap manager invokes sbrk to increase the size of the heap. This is done by moving the program break to a higher address, effectively extending the heap’s boundaries. The newly allocated memory is then used to expand the top chunk, the largest free chunk in the heap. The sbrk call increases the size of the top chunk, allowing it to accommodate new allocations. As a result, the heap grows upward, providing additional space for dynamic memory allocation, and the program can continue to request and manage memory efficiently.\nHeap Layout Before sbrk Syscall\nHeap Layout After sbrk Syscall\nUsing mmap for Larger Allocation Larger memory chunks are allocated using mmap. When a program requests a chunk of memory that exceeds the usual size limits of the heap, the heap manager uses mmap to allocate this memory outside the heap’s standard area. In the chunk metadata, which contains information about the memory block such as size and status, the M bit is set to indicate that this allocation was performed using mmap. Metadata for chunks managed by mmap includes flags that denote the allocation method and manage the block’s lifecycle. When this memory is no longer needed and is freed by the free() function, the heap manager uses munmap to return the entire mapped region of memory back to the system, ensuring that the resources are released appropriately. This separation of memory management methods helps optimize performance and manage large memory requests efficiently.\nFreeing Allocated Chunk 1. Freeing a Chunk In glibc’s ptmalloc, when a chunk of memory is freed, the allocator updates the chunk’s metadata to reflect its new status as free. This involves setting the prev_size field (which holds the size of the previous chunk) and adjusting the size field to indicate that the chunk is no longer allocated. The in_use flag is cleared to mark the chunk as available. Optionally, the allocator may zero out the chunk’s data to prevent residual data from being exposed, although this is not always performed due to performance trade-offs. Once the chunk’s metadata is updated, it is prepared for insertion into the appropriate free list or bin, based on its size and the allocator’s configuration.\n2. Adding to Free Lists/Bins After the chunk is marked as free, it is added to the appropriate free list or bin depending on its size and the state of the thread cache. If tcache is enabled and the chunk’s size matches one of the tcache size classes, the chunk is placed into the corresponding thread-specific tcache bin. This bin is part of a per-thread cache designed to reduce allocation and deallocation latency by avoiding contention with other threads. If the chunk does not fit into any tcache bin—either because it is too large or tcache is not utilized—it is added to the global free list. The global free list is organized by size classes and is used to manage free chunks that can be shared among all threads, improving scalability.\n3. Managing Free Lists Effective management of free lists involves several critical operations to optimize memory usage and reduce fragmentation. When a chunk is inserted into a free list or bin, the allocator updates its metadata to integrate the chunk into the appropriate list for its size class. The chunk is linked to other free chunks using pointers maintained in the free list’s data structure. Additionally, if the freed chunk is adjacent to other free chunks in memory, ptmalloc performs coalescing, which merges these adjacent chunks into a single larger block. This reduces fragmentation and increases the size of contiguous free memory. The allocator continuously updates its internal data structures to reflect the changes, ensuring accurate tracking of available memory and maintaining efficient allocation strategies.\nReference\nhttps://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/\nhttps://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/\nhttps://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/\nhttps://codebrowser.dev/glibc/glibc/malloc/malloc.c.html\n",
  "wordCount" : "1552",
  "inLanguage": "en",
  "datePublished": "2024-08-16T00:00:00Z",
  "dateModified": "2024-08-16T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Mr_N1"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/heapexp2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mr_N₁gativ3",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Mr_N₁gativ3 (Alt + H)">Mr_N₁gativ3</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Heap Exploitation Part 2
    </h1>
    <div class="post-description">
      Memory Allocation and Deallocation Process
    </div>
    <div class="post-meta"><span title='2024-08-16 00:00:00 +0000 UTC'>August 16, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Mr_N1</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#basics-memory-allocation" aria-label="Basics Memory Allocation">Basics Memory Allocation</a></li>
                <li>
                    <a href="#chunk-allocation" aria-label="Chunk Allocation">Chunk Allocation</a></li>
                <li>
                    <a href="#allocation-from-free-lists-bins" aria-label="Allocation From Free Lists (Bins)">Allocation From Free Lists (Bins)</a></li>
                <li>
                    <a href="#allocation-from-top-chunk" aria-label="Allocation From Top Chunk">Allocation From Top Chunk</a></li>
                <li>
                    <a href="#requesting-kernel-for-extra-heap-memory" aria-label="Requesting Kernel For Extra Heap Memory">Requesting Kernel For Extra Heap Memory</a></li>
                <li>
                    <a href="#using-mmap-for-larger-allocation" aria-label="Using mmap for Larger Allocation">Using mmap for Larger Allocation</a></li>
                <li>
                    <a href="#freeing-allocated-chunk" aria-label="Freeing Allocated Chunk">Freeing Allocated Chunk</a></li>
                <li>
                    <a href="#1-freeing-a-chunk" aria-label="1. Freeing a Chunk">1. Freeing a Chunk</a></li>
                <li>
                    <a href="#2-adding-to-free-listsbins" aria-label="2. Adding to Free Lists/Bins">2. Adding to Free Lists/Bins</a></li>
                <li>
                    <a href="#3-managing-free-lists" aria-label="3. Managing Free Lists">3. Managing Free Lists</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="intro"><strong>Intro</strong><a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h3>
<p>Welcome back to the second part of the Heap Exploitation Series. In the previous part, I provided a basic overview of glibc’s heap implementation. If you haven&rsquo;t read that part yet, I highly recommend you go back and check it out to understand fundamental concepts such as chunks and bins. However, if you are already familiar with these basics, you can continue reading here. In this post, we will delve deeper into the process of memory allocation and deallocation in glibc’s heap. We’ll explore how memory is allocated for a process and the mechanisms involved in freeing memory.</p>
<hr>
<h3 id="basics-memory-allocation"><strong>Basics Memory Allocation</strong><a hidden class="anchor" aria-hidden="true" href="#basics-memory-allocation">#</a></h3>
<p>When you request memory for your program, for example, 0x10 bytes of memory, by calling <code>malloc</code>, it returns a pointer to the allocated memory space where you can store your data. However, the allocation process involves more than simply providing 16 bytes of free memory space.</p>
<p>The heap manager performs several additional tasks behind the scenes. It keeps track of all allocated memory chunks by storing metadata alongside the user-requested space. This metadata includes information such as the size of the allocated chunk and its status (e.g., whether it is free or in use). Additionally, the heap manager ensures proper memory alignment for better efficiency. On 32-bit systems, memory is typically aligned to 0x8 (8) bytes, while on 64-bit systems, it is aligned to 0x10 (16) bytes.</p>
<blockquote>
<p>When you request 0x10 (16) bytes of memory, the heap manager actually allocates more than just 16 bytes. In practice, it typically allocates a total of 32 bytes. This allocation includes 16 bytes for metadata or a header, which contains information about the allocated chunk, such as its size and status. Additionally, it includes the 16 bytes you requested for storing your data. To ensure proper alignment, particularly on 64-bit systems where memory is aligned to 16-byte blocks, 6 bytes of padding are added. This padding ensures that the memory allocation is aligned correctly, making the total allocated memory 32 bytes, accommodating both the user-requested space and the necessary overhead for metadata and alignment.</p></blockquote>
<pre tabindex="0"><code>Requested Size: 10 bytes
Total Without Alignment: 10 + 16 = 26 bytes
Alignment Padding: To align to 16 bytes, we need 6 more bytes to reach 32 bytes
Total Allocated Size: 32 bytes
Overhead: 32 - 10 = 22 bytes
</code></pre><blockquote>
<p><strong>Allocated Chunk Example</strong></p></blockquote>
<p><img alt="image.png" loading="lazy" src="/heap_images/image.png"></p>
<p>After that heap manager mark this chunk as allocated and returns a pointer to the “User Data” region inside the chunk. which is the same return pointer you get from the malloc after the memory allocation.</p>
<hr>
<h3 id="chunk-allocation"><strong>Chunk Allocation</strong><a hidden class="anchor" aria-hidden="true" href="#chunk-allocation">#</a></h3>
<p><em><strong>Before Talking about how a Chunk is allocated lets talk about how a heap is created in the first place</strong></em></p>
<p>When <code>malloc</code> is called for the first time, the heap manager initiates the creation of the heap segment for the program. Initially, the operating system does not allocate any memory for the heap, but when the first memory allocation request is made, the heap manager uses system calls such as <code>brk</code> or <code>sbrk</code> to adjust the program break, effectively expanding the heap segment by allocating additional memory from the operating system. If the request is for a large amount of memory, the heap manager may use <code>mmap</code> to map a new memory region directly. The heap manager then initializes its internal data structures, such as free lists or bins, to manage the newly allocated heap space. This setup allows the heap to handle subsequent memory allocation and deallocation requests efficiently.</p>
<p><em><strong>Now lets see how the heap manager allocates the chunks.</strong></em></p>
<p>There are various way a memory chunk can be allocated.</p>
<ol>
<li><strong>Allocation From Free List (bins)</strong></li>
<li><strong>Allocation From Top Chunk</strong></li>
<li><strong>Requesting Kernel For Extra Heap Memory</strong></li>
<li><strong>Using mmap for Larger Allocation</strong></li>
</ol>
<h3 id="allocation-from-free-lists-bins"><strong>Allocation From Free Lists (Bins)</strong><a hidden class="anchor" aria-hidden="true" href="#allocation-from-free-lists-bins">#</a></h3>
<p>The heap manager has multiple free lists, also known as bins. These bins store all the chunks that are freed. The freed chunks are stored in different lists based on their size. For example, chunks larger than 512 bytes are stored in the large bin.</p>
<p>When you request memory from the heap manager, it will search through the bins and try to find a free chunk that can fit the requested size. If the heap manager finds a chunk that is big enough to fulfill your allocation request, it will mark that chunk as allocated and return a pointer to the &ldquo;User Data&rdquo; area to the program. After that chunk is no longer in use and gets freed, the heap manager will add that chunk back to the free list (bin).</p>
<p><img alt="image.png" loading="lazy" src="/heap_images/image2.png"></p>
<h3 id="allocation-from-top-chunk"><strong>Allocation From Top Chunk</strong><a hidden class="anchor" aria-hidden="true" href="#allocation-from-top-chunk">#</a></h3>
<p>The top chunk is a unique feature of the GLIBC memory allocator. It represents the last free chunk in the heap and is notable for being the largest among all the chunks. This chunk can be dynamically expanded as needed. There is only one top chunk in the entire heap. If the heap manager fails to find a suitable free chunk that matches desired allocation request, then it will create a new chunk from the top chunk and resize the top chunk accordingly and allocate that newly create chunk to the program.</p>
<p><img alt="image.png" loading="lazy" src="/heap_images/image%202.png"></p>
<h3 id="requesting-kernel-for-extra-heap-memory"><strong>Requesting Kernel For Extra Heap Memory</strong><a hidden class="anchor" aria-hidden="true" href="#requesting-kernel-for-extra-heap-memory">#</a></h3>
<p>When the heap memory is fully exhausted or there is insufficient memory available at the top chunk to allocate a large-sized chunk, the heap manager requests the kernel to add more memory to the heap, expanding its size. The heap manager expands heap memory using the <code>sbrk</code> system call by adjusting the program break, which defines the end of the heap. When a program requests more memory than is available within the current heap, the heap manager invokes <code>sbrk</code> to increase the size of the heap. This is done by moving the program break to a higher address, effectively extending the heap&rsquo;s boundaries. The newly allocated memory is then used to expand the top chunk, the largest free chunk in the heap. The <code>sbrk</code> call increases the size of the top chunk, allowing it to accommodate new allocations. As a result, the heap grows upward, providing additional space for dynamic memory allocation, and the program can continue to request and manage memory efficiently.</p>
<p><strong>Heap Layout Before sbrk Syscall</strong></p>
<p><img alt="Screenshot from 2024-08-15 23-52-42.png" loading="lazy" src="/heap_images/Screenshot_from_2024-08-15_23-52-42.png"></p>
<p><strong>Heap Layout After sbrk Syscall</strong></p>
<p><img alt="Screenshot from 2024-08-15 23-54-52.png" loading="lazy" src="/heap_images/a54725da-7e96-4e59-bede-1caeace4ae4a.png"></p>
<h3 id="using-mmap-for-larger-allocation"><strong>Using mmap for Larger Allocation</strong><a hidden class="anchor" aria-hidden="true" href="#using-mmap-for-larger-allocation">#</a></h3>
<p>Larger memory chunks are allocated using <code>mmap</code>. When a program requests a chunk of memory that exceeds the usual size limits of the heap, the heap manager uses <code>mmap</code> to allocate this memory outside the heap&rsquo;s standard area. In the chunk metadata, which contains information about the memory block such as size and status, the <code>M</code> bit is set to indicate that this allocation was performed using <code>mmap</code>. Metadata for chunks managed by <code>mmap</code> includes flags that denote the allocation method and manage the block’s lifecycle. When this memory is no longer needed and is freed by the <code>free()</code> function, the heap manager uses <code>munmap</code> to return the entire mapped region of memory back to the system, ensuring that the resources are released appropriately. This separation of memory management methods helps optimize performance and manage large memory requests efficiently.</p>
<hr>
<h3 id="freeing-allocated-chunk"><strong>Freeing Allocated Chunk</strong><a hidden class="anchor" aria-hidden="true" href="#freeing-allocated-chunk">#</a></h3>
<h3 id="1-freeing-a-chunk"><strong>1. Freeing a Chunk</strong><a hidden class="anchor" aria-hidden="true" href="#1-freeing-a-chunk">#</a></h3>
<p>In glibc’s ptmalloc, when a chunk of memory is freed, the allocator updates the chunk&rsquo;s metadata to reflect its new status as free. This involves setting the <code>prev_size</code> field (which holds the size of the previous chunk) and adjusting the <code>size</code> field to indicate that the chunk is no longer allocated. The <code>in_use</code> flag is cleared to mark the chunk as available. Optionally, the allocator may zero out the chunk&rsquo;s data to prevent residual data from being exposed, although this is not always performed due to performance trade-offs. Once the chunk’s metadata is updated, it is prepared for insertion into the appropriate free list or bin, based on its size and the allocator’s configuration.</p>
<p><img alt="image.png" loading="lazy" src="/heap_images/image%203.png"></p>
<h3 id="2-adding-to-free-listsbins"><strong>2. Adding to Free Lists/Bins</strong><a hidden class="anchor" aria-hidden="true" href="#2-adding-to-free-listsbins">#</a></h3>
<p>After the chunk is marked as free, it is added to the appropriate free list or bin depending on its size and the state of the thread cache. If tcache is enabled and the chunk&rsquo;s size matches one of the tcache size classes, the chunk is placed into the corresponding thread-specific tcache bin. This bin is part of a per-thread cache designed to reduce allocation and deallocation latency by avoiding contention with other threads. If the chunk does not fit into any tcache bin—either because it is too large or tcache is not utilized—it is added to the global free list. The global free list is organized by size classes and is used to manage free chunks that can be shared among all threads, improving scalability.</p>
<p><img alt="image.png" loading="lazy" src="/heap_images/image%204.png"></p>
<h3 id="3-managing-free-lists"><strong>3. Managing Free Lists</strong><a hidden class="anchor" aria-hidden="true" href="#3-managing-free-lists">#</a></h3>
<p>Effective management of free lists involves several critical operations to optimize memory usage and reduce fragmentation. When a chunk is inserted into a free list or bin, the allocator updates its metadata to integrate the chunk into the appropriate list for its size class. The chunk is linked to other free chunks using pointers maintained in the free list’s data structure. Additionally, if the freed chunk is adjacent to other free chunks in memory, ptmalloc performs coalescing, which merges these adjacent chunks into a single larger block. This reduces fragmentation and increases the size of contiguous free memory. The allocator continuously updates its internal data structures to reflect the changes, ensuring accurate tracking of available memory and maintaining efficient allocation strategies.</p>
<p><img alt="image.png" loading="lazy" src="/heap_images/image%205.png"></p>
<hr>
<p>Reference</p>
<hr>
<p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a></p>
<p><a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/</a></p>
<p><a href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/">https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/</a></p>
<p><a href="https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html">https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/heapexp3/">
    <span class="title">« Prev</span>
    <br>
    <span>Heap Exploitation Part 3</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/heapexp1/">
    <span class="title">Next »</span>
    <br>
    <span>Heap Exploitation Part 1</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 2 on x"
            href="https://x.com/intent/tweet/?text=Heap%20Exploitation%20Part%202&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp2%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 2 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp2%2f&amp;title=Heap%20Exploitation%20Part%202&amp;summary=Heap%20Exploitation%20Part%202&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 2 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp2%2f&title=Heap%20Exploitation%20Part%202">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 2 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 2 on whatsapp"
            href="https://api.whatsapp.com/send?text=Heap%20Exploitation%20Part%202%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp2%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 2 on telegram"
            href="https://telegram.me/share/url?text=Heap%20Exploitation%20Part%202&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp2%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Heap Exploitation Part 2 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Heap%20Exploitation%20Part%202&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fheapexp2%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Mr_N₁gativ3</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
